// Lark grammar for Manchester Syntax (OWL DL)

?start: equivalence
      | subsumption
      | disjoint

equivalence: base "EquivalentTo" base
subsumption: base "SubClassOf" base
disjoint: base "DisjointWith" base
intersection: base "and" base
union: base "or" base
?base: (object | op_res | dp_res | intersection | union | parenthesized | negated)
?parenthesized: "(" base ")"
// so far, ontor supports negation only for individual restrictions
negated: "not" (object | op_res | dp_res | parenthesized)
// inverse only makes sense for OPs
op_res: (prop | inverse_prop) (card_res INT | res) object
dp_res: prop (card_res INT | res) val_res
object: CNAME
prop: CNAME
inverse_prop: "Inverse (" WORD ")"

// value restrictions
// values may take one of the following forms: 5 | "5"^^xsd:integer | xsd:integer [ > 0 , < 5 ]
val: NUMBER | "\""NUMBER"\"^^"datatype
min_ex: ">" val
min_in: ">=" val
max_in: "<=" val
max_ex: "<" val
?lim: (min_ex | min_in | max_in | max_ex)
range: datatype "[" [(val | lim) ("," (val | lim))?] "]"
val_res: (val | range | datatype)
res: "some"             -> some
   | "only"             -> only
   | "value"            -> value
card_res: "min"         -> min
        | "max"         -> max
        | "exactly"     -> exactly
// data types currently supported by Owlready2: https://owlready2.readthedocs.io/en/latest/properties.html?highlight=float#data-property
datatype: "xsd:integer"     -> integer
        | "xsd:float"       -> float
        | "xsd:boolean"     -> boolean
        | "xsd:string"      -> string
        | "xsd:dateTime"    -> datetime

// imports
%import common.WORD
%import common.CNAME
%import common.NUMBER
%import common.INT
%import common.WS
%ignore WS
